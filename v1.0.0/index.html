<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · WunDeeDB.jl</title><meta name="title" content="Home · WunDeeDB.jl"/><meta property="og:title" content="Home · WunDeeDB.jl"/><meta property="twitter:title" content="Home · WunDeeDB.jl"/><meta name="description" content="Documentation for WunDeeDB.jl."/><meta property="og:description" content="Documentation for WunDeeDB.jl."/><meta property="twitter:description" content="Documentation for WunDeeDB.jl."/><meta property="og:url" content="https://mantzaris.github.io/WunDeeDB.jl/"/><meta property="twitter:url" content="https://mantzaris.github.io/WunDeeDB.jl/"/><link rel="canonical" href="https://mantzaris.github.io/WunDeeDB.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>WunDeeDB.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Supported-Data-Types"><span>Supported Data Types</span></a></li><li><a class="tocitem" href="#Exported-Functions"><span>Exported Functions</span></a></li><li><a class="tocitem" href="#Quick-Example-(HNSW,-LM‐DiskANN,-and-Linear)"><span>Quick Example (HNSW, LM‐DiskANN, &amp; Linear)</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mantzaris/WunDeeDB.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mantzaris/WunDeeDB.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#WunDeeDB">WunDeeDB</a></li><li class="no-marker"><ul><li><a href="#Supported-Data-Types">Supported Data Types</a></li><li><a href="#Exported-Functions">Exported Functions</a></li><li><a href="#Quick-Example-(HNSW,-LM‐DiskANN,-and-Linear)">Quick Example (HNSW, LM‐DiskANN, &amp; Linear)</a></li></ul></li></ul><h1 id="WunDeeDB"><a class="docs-heading-anchor" href="#WunDeeDB">WunDeeDB</a><a id="WunDeeDB-1"></a><a class="docs-heading-anchor-permalink" href="#WunDeeDB" title="Permalink"></a></h1><p>WunDeeDB is a Julia package for <strong>storing and querying embeddings</strong> in a SQLite database. It supports a variety of numerical types (including <code>Float16</code>, <code>Float32</code>, <code>Float64</code>, and various integer types) and can integrate with approximate nearest neighbor indices (like <strong>HNSW</strong> or <strong>LM‐DiskANN</strong>). By default, the module provides a <strong>linear fallback</strong> for distance queries if no ANN method is enabled.</p><p>This module exposes <strong>bulk operations</strong> for insertions, deletions, and updates (capped at a certain transaction size) and provides convenient high‐level functions (<code>insert_embeddings</code>, <code>delete_embeddings</code>, <code>search_ann</code>, etc.) so users can focus on storing and retrieving embeddings without worrying about the underlying details of adjacency structures. Whether you want a simple linear search or a more scalable approach with HNSW or LM‐DiskANN, WunDeeDB automatically handles the index creation and updates.</p><p>Internally, WunDeeDB stores embedding vectors in a <code>BLOB</code> column, along with metadata (<code>embedding_length</code>, <code>data_type</code>) in a meta table to ensure consistency. When you choose <code>ann=&quot;hnsw&quot;</code> or <code>ann=&quot;lmdiskann&quot;</code>, each call to <code>insert_embeddings</code> automatically triggers adjacency insertion for that node, enabling fast approximate searches for new queries via <code>search_ann</code>.</p><hr/><h2 id="Supported-Data-Types"><a class="docs-heading-anchor" href="#Supported-Data-Types">Supported Data Types</a><a id="Supported-Data-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-Data-Types" title="Permalink"></a></h2><p>WunDeeDB supports storing embeddings of these types (any dimension in principle):</p><p>Float16, Float32, Float64, BigFloat, Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Int128, UInt128</p><hr/><h2 id="Exported-Functions"><a class="docs-heading-anchor" href="#Exported-Functions">Exported Functions</a><a id="Exported-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-Functions" title="Permalink"></a></h2><p><strong>General DB</strong>  </p><ul><li><code>initialize_db</code>, <code>open_db</code>, <code>close_db</code>, <code>delete_db</code>, <code>delete_all_embeddings</code>  </li><li><code>get_meta_data</code>, <code>update_description</code>, <code>count_entries</code></li></ul><p><strong>Embeddings</strong>  </p><ul><li><code>insert_embeddings</code>, <code>delete_embeddings</code>, <code>update_embeddings</code>  </li><li><code>get_embeddings</code>, <code>get_all_ids</code>, <code>get_all_embeddings</code>, <code>random_embeddings</code></li></ul><p><strong>ANN / Searching</strong>  </p><ul><li><code>search_ann</code> (resolves to HNSW, LM‐DiskANN, or linear fallback)  </li><li><code>supported_distance_metrics</code></li></ul><p><strong>Linear Search</strong>  </p><ul><li><code>linear_search_all_embeddings</code>, <code>linear_search_ids</code>,   <code>linear_search_iteration</code>, <code>linear_search_ids_batched</code></li></ul><hr/><h2 id="Quick-Example-(HNSW,-LM‐DiskANN,-and-Linear)"><a class="docs-heading-anchor" href="#Quick-Example-(HNSW,-LM‐DiskANN,-and-Linear)">Quick Example (HNSW, LM‐DiskANN, &amp; Linear)</a><a id="Quick-Example-(HNSW,-LM‐DiskANN,-and-Linear)-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Example-(HNSW,-LM‐DiskANN,-and-Linear)" title="Permalink"></a></h2><p>Below is a <strong>minimal code snippet</strong> showing how to create a database, insert a couple embeddings, and then run searches with <strong>HNSW</strong>, <strong>LM‐DiskANN</strong>, and a <strong>linear</strong> fallback. (We assume each approach uses a separate DB for illustration.)</p><p>Install via: <code>(@v1.9) pkg&gt; add https://github.com/mantzaris/WunDeeDB.jl</code></p><pre><code class="language-julia hljs">using WunDeeDB

#
# 1) Example: HNSW
#
hnsw_db = &quot;temp_hnsw.sqlite&quot;
initialize_db(hnsw_db, 3, &quot;Float32&quot;; ann=&quot;hnsw&quot;)
insert_embeddings(hnsw_db, &quot;node1&quot;, Float32[0.0, 0.0, 0.0])
insert_embeddings(hnsw_db, &quot;node2&quot;, Float32[1.0, 1.0, 1.0])

# search for top-1 neighbor using HNSW adjacency
found_hnsw = search_ann(hnsw_db, Float32[0.1, 0.1, 0.1], &quot;euclidean&quot;; top_k=1)
println(&quot;HNSW found: &quot;, found_hnsw)

#
# 2) Example: LM-DiskANN
#
lmdiskann_db = &quot;temp_lmdiskann.sqlite&quot;
initialize_db(lmdiskann_db, 3, &quot;Float32&quot;; ann=&quot;lmdiskann&quot;)
insert_embeddings(lmdiskann_db, &quot;nodeA&quot;, Float32[0.5, 0.5, 0.4])
insert_embeddings(lmdiskann_db, &quot;nodeB&quot;, Float32[0.8, 0.9, 0.7])

# search for top-2 neighbors using LM-DiskANN adjacency
found_lmdiskann = search_ann(lmdiskann_db, Float32[0.55, 0.55, 0.35], &quot;euclidean&quot;; top_k=2)
println(&quot;LM-DiskANN found: &quot;, found_lmdiskann)

#
# 3) Example: Linear fallback (no ann)
#
linear_db = &quot;temp_linear.sqlite&quot;
initialize_db(linear_db, 3, &quot;Float32&quot;; ann=&quot;&quot;)
insert_embeddings(linear_db, &quot;X&quot;, Float32[0.0, 1.0, 2.0])
insert_embeddings(linear_db, &quot;Y&quot;, Float32[1.0, 1.0, 2.0])

# fallback linear search:
found_linear = search_ann(linear_db, Float32[0.1, 1.0, 2.1], &quot;euclidean&quot;; top_k=2)
println(&quot;Linear fallback found: &quot;, found_linear)</code></pre><p>and some more examples</p><pre><code class="language-julia hljs">using WunDeeDB

#
# 1) Initialize a database, dimension=3, Float32, no ann
#
db_path = &quot;my_demo.sqlite&quot;
initialize_db(db_path, 3, &quot;Float32&quot;; keep_conn_open=true, description=&quot;Demo DB&quot;, ann=&quot;&quot;)  

#
# 2) Insert Embeddings
#    - single key =&gt; single embedding
#    - multiple keys =&gt; vector-of-vectors
#
insert_embeddings(db_path, &quot;key1&quot;, Float32[0.1, 0.2, 0.3])
insert_embeddings(db_path, [&quot;key2&quot;, &quot;key3&quot;], [Float32[1.0, 1.1, 1.2], Float32[9.0, 9.1, 9.2]])

#
# 3) Retrieve Embeddings
#    - single key =&gt; single vector
#    - multiple keys =&gt; dictionary of key =&gt; vector
#
# Single Key
my_embedding = get_embeddings(db_path, &quot;key1&quot;)  
println(&quot;key1 embedding: &quot;, my_embedding)

# Multiple keys
some_embeddings = get_embeddings(db_path, [&quot;key2&quot;, &quot;key3&quot;])
println(&quot;Retrieved keys: &quot;, keys(some_embeddings))
println(&quot;key2 embedding =&gt; &quot;, some_embeddings[&quot;key2&quot;])
println(&quot;key3 embedding =&gt; &quot;, some_embeddings[&quot;key3&quot;])

#
# 4) Delete Embeddings by Keys
#    - Single or multiple keys can be removed
#
delete_embeddings(db_path, &quot;key1&quot;)
delete_embeddings(db_path, [&quot;key2&quot;, &quot;key3&quot;])

# After deletion, retrieving them returns nothing or an error
check_after_delete = get_embeddings(db_path, &quot;key1&quot;)
println(&quot;key1 after deletion =&gt; &quot;, check_after_delete)  # likely nothing or error string

#
# 5) Close DB
#
close_db()  # or close_db(db_path) if your code does that
</code></pre><h3 id="How-it-works:"><a class="docs-heading-anchor" href="#How-it-works:">How it works:</a><a id="How-it-works:-1"></a><a class="docs-heading-anchor-permalink" href="#How-it-works:" title="Permalink"></a></h3><pre><code class="nohighlight hljs">Initialization: We pick ann=&quot;hnsw&quot;, ann=&quot;lmdiskann&quot;, or &quot;&quot; to decide which adjacency method is used.
Insertion: Each call to insert_embeddings(db, node_id, vector) checks the ann type and updates adjacency automatically if needed.
Search: The high‐level function search_ann(db, query, metric; top_k) uses the specified adjacency (HNSW, LM‐DiskANN, or none -&gt; linear).</code></pre><h3 id="Bulk-Limit-and-Data-Checking"><a class="docs-heading-anchor" href="#Bulk-Limit-and-Data-Checking">Bulk Limit &amp; Data Checking</a><a id="Bulk-Limit-and-Data-Checking-1"></a><a class="docs-heading-anchor-permalink" href="#Bulk-Limit-and-Data-Checking" title="Permalink"></a></h3><p>WunDeeDB enforces a bulk limit of 1000 embeddings per transaction to avoid overly large inserts. You can batch multiple calls if you have more than 1000. The module also checks that the embedding dimension and data type match what’s stored in the EmbeddingsMetaData table, ensuring consistency (so you can’t insert a Float32 with length=100 into a DB initialized for Float16 length=128, etc.).</p><p>For more advanced usage (e.g., partial BFS expansions, recall tests, multi-level HNSW), see our test suite or higher-level documentation. WunDeeDB aims to handle typical ANN workflows seamlessly via a single API.</p><h3 id="naming-of-the-package"><a class="docs-heading-anchor" href="#naming-of-the-package">naming of the package</a><a id="naming-of-the-package-1"></a><a class="docs-heading-anchor-permalink" href="#naming-of-the-package" title="Permalink"></a></h3><p>In his book How JavaScript Works, Douglas Crockford advocates for spelling the word &quot;one&quot; as &quot;wun&quot; to better align with its pronunciation. He argues that the traditional spelling does not conform to standard English pronunciation rules and that having the word for 1 start with a letter resembling 0 is problematic. Since a vector database is a database for 1-D objects, it is called <strong>Wun-Dee-DB</strong>. </p><p>Along with a simple name should be the simple approach for a: zero-config, embedded, WAL, just works vector database.</p><ul><li><a href="#WunDeeDB.close_db-Tuple{SQLite.DB}"><code>WunDeeDB.close_db</code></a></li><li><a href="#WunDeeDB.count_entries-Tuple{SQLite.DB}"><code>WunDeeDB.count_entries</code></a></li><li><a href="#WunDeeDB.delete_db-Tuple{String}"><code>WunDeeDB.delete_db</code></a></li><li><a href="#WunDeeDB.delete_embeddings-Tuple{SQLite.DB, Any}"><code>WunDeeDB.delete_embeddings</code></a></li><li><a href="#WunDeeDB.get_adjacent_id-Tuple{SQLite.DB, Any}"><code>WunDeeDB.get_adjacent_id</code></a></li><li><a href="#WunDeeDB.get_all_embeddings-Tuple{SQLite.DB}"><code>WunDeeDB.get_all_embeddings</code></a></li><li><a href="#WunDeeDB.get_all_ids-Tuple{SQLite.DB}"><code>WunDeeDB.get_all_ids</code></a></li><li><a href="#WunDeeDB.get_embeddings-Tuple{SQLite.DB, Any}"><code>WunDeeDB.get_embeddings</code></a></li><li><a href="#WunDeeDB.get_meta_data-Tuple{SQLite.DB}"><code>WunDeeDB.get_meta_data</code></a></li><li><a href="#WunDeeDB.get_supported_data_types-Tuple{}"><code>WunDeeDB.get_supported_data_types</code></a></li><li><a href="#WunDeeDB.infer_data_type-Tuple{AbstractVector{&lt;:Number}}"><code>WunDeeDB.infer_data_type</code></a></li><li><a href="#WunDeeDB.initialize_db-Tuple{String, Int64, String}"><code>WunDeeDB.initialize_db</code></a></li><li><a href="#WunDeeDB.insert_embeddings-Tuple{SQLite.DB, Any, Any}"><code>WunDeeDB.insert_embeddings</code></a></li><li><a href="#WunDeeDB.linear_search_all_embeddings-Tuple{String, AbstractVector, String}"><code>WunDeeDB.linear_search_all_embeddings</code></a></li><li><a href="#WunDeeDB.linear_search_ids-Tuple{String, AbstractVector, String}"><code>WunDeeDB.linear_search_ids</code></a></li><li><a href="#WunDeeDB.linear_search_ids_batched-Tuple{String, AbstractVector, String}"><code>WunDeeDB.linear_search_ids_batched</code></a></li><li><a href="#WunDeeDB.linear_search_iteration-Tuple{String, AbstractVector, String}"><code>WunDeeDB.linear_search_iteration</code></a></li><li><a href="#WunDeeDB.open_db-Tuple{String}"><code>WunDeeDB.open_db</code></a></li><li><a href="#WunDeeDB.random_embeddings-Tuple{SQLite.DB, Int64}"><code>WunDeeDB.random_embeddings</code></a></li><li><a href="#WunDeeDB.supported_distance_metrics-Tuple{}"><code>WunDeeDB.supported_distance_metrics</code></a></li><li><a href="#WunDeeDB.update_description"><code>WunDeeDB.update_description</code></a></li><li><a href="#WunDeeDB.update_embeddings-Tuple{SQLite.DB, Any, Any}"><code>WunDeeDB.update_embeddings</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.close_db-Tuple{SQLite.DB}" href="#WunDeeDB.close_db-Tuple{SQLite.DB}"><code>WunDeeDB.close_db</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>close_db(db::SQLite.DB)</p><p>Close an open SQLite database connection.</p><p>This function is a simple wrapper around SQLite.close to ensure that the provided database connection is properly closed when it is no longer needed.</p><p><strong>Arguments</strong></p><ul><li>db::SQLite.DB: (optional) The SQLite database connection to be closed, and if not included the default of the persistent db object is used</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">db = open_db(&quot;data/mydatabase.sqlite&quot;)
# Perform database operations...
close_db(db)

or 
close_db()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/WunDeeDB.jl#L340-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.count_entries-Tuple{SQLite.DB}" href="#WunDeeDB.count_entries-Tuple{SQLite.DB}"><code>WunDeeDB.count_entries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Count the number of entries in the main table of the SQLite database.</p><p>This function is overloaded to support both an active database connection and a database file path:</p><ul><li><code>count_entries(db::SQLite.DB; update_meta::Bool=false)</code>: Counts entries using an active database connection.</li><li><code>count_entries(db_path::String; update_meta::Bool=false)</code>: Opens the database at the specified path, counts entries, optionally updates the meta table, and then closes the connection.</li></ul><p><strong>Arguments</strong></p><ul><li>For <code>count_entries(db::SQLite.DB; update_meta::Bool=false)</code>:<ul><li><code>db::SQLite.DB</code>: An active SQLite database connection.</li></ul></li><li>For <code>count_entries(db_path::String; update_meta::Bool=false)</code>:<ul><li><code>db_path::String</code>: The file path to the SQLite database.</li></ul></li><li><code>update_meta::Bool=false</code>: When set to <code>true</code>, updates the meta table with the current count. If the count is 0, it clears the meta information (i.e., sets <code>embedding_count</code> to 0 and resets <code>embedding_length</code> if applicable).</li></ul><p><strong>Returns</strong></p><ul><li>The number of entries (an integer) in the main table.</li><li>In the <code>db_path</code> overload, returns a <code>String</code> error message if an error occurs.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Using an active database connection:
entry_count = count_entries(db, update_meta=true)
println(&quot;Number of entries: &quot;, entry_count)

# Using a database file path:
entry_count = count_entries(&quot;my_database.db&quot;, update_meta=true)
println(&quot;Number of entries: &quot;, entry_count)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/WunDeeDB.jl#L1463-L1491">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.delete_db-Tuple{String}" href="#WunDeeDB.delete_db-Tuple{String}"><code>WunDeeDB.delete_db</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Delete the database file at the specified path.</p><p><strong>Arguments</strong></p><ul><li><code>db_path::String</code>: The file path of the database to delete.</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if the file was successfully deleted.</li><li>A <code>String</code> error message if deletion fails or if the file does not exist.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = delete_db(&quot;my_database.db&quot;)
if result === true
    println(&quot;Database deleted successfully.&quot;)
else
    println(&quot;Error: &#39;result&#39;&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/WunDeeDB.jl#L376-L395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.delete_embeddings-Tuple{SQLite.DB, Any}" href="#WunDeeDB.delete_embeddings-Tuple{SQLite.DB, Any}"><code>WunDeeDB.delete_embeddings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Delete one or more embeddings from the database using their ID(s).</p><p>This function is overloaded to support both an active database connection and a database file path:</p><ul><li><code>delete_embeddings(db::SQLite.DB, id_input)</code>: Deletes embeddings using an open database connection.</li><li><code>delete_embeddings(db_path::String, id_input)</code>: Opens the database at the specified path, deletes the embeddings, and then closes the connection.</li></ul><p><strong>Arguments</strong></p><ul><li>For <code>delete_embeddings(db::SQLite.DB, id_input)</code>:<ul><li><code>db::SQLite.DB</code>: An active SQLite database connection.</li><li><code>id_input</code>: A single ID or a collection of IDs (can be any type convertible to a string) identifying the embeddings to be deleted.</li></ul></li><li>For <code>delete_embeddings(db_path::String, id_input)</code>:<ul><li><code>db_path::String</code>: The file path to the SQLite database.</li><li><code>id_input</code>: A single ID or a collection of IDs identifying the embeddings to be deleted.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if the deletion is successful.</li><li>A <code>String</code> error message if an error occurs during deletion.</li></ul><p><strong>Examples</strong></p><p>Using an active database connection:</p><pre><code class="language-julia hljs">result = delete_embeddings(db, [1, 2, 3])
if result === true
    println(&quot;Embeddings deleted successfully.&quot;)
else
    println(&quot;Error: &quot;, result)
end

Using a database file path:

result = delete_embeddings(&quot;my_database.db&quot;, 1)
if result === true
    println(&quot;Embedding deleted successfully.&quot;)
else
    println(&quot;Error: &quot;, result)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/WunDeeDB.jl#L794-L833">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.get_adjacent_id-Tuple{SQLite.DB, Any}" href="#WunDeeDB.get_adjacent_id-Tuple{SQLite.DB, Any}"><code>WunDeeDB.get_adjacent_id</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Retrieve the adjacent record relative to a given <code>current_id</code> from the SQLite database.</p><p>This function is overloaded to support both an active database connection and a database file path:</p><ul><li><code>get_adjacent_id(db::SQLite.DB, current_id; direction=&quot;next&quot;, full_row=true)</code>: Uses an active connection.</li><li><code>get_adjacent_id(db_path::String, current_id; direction=&quot;next&quot;, full_row=true)</code>: Opens the database at the specified path, retrieves the adjacent record, and then closes the connection.</li></ul><p>The function returns the record immediately after (or before) the specified <code>current_id</code> based on the <code>direction</code> parameter. When <code>full_row</code> is <code>true</code>, the returned result is a named tuple containing the <code>id_text</code>, the decoded embedding vector, and the stored <code>data_type</code>. When <code>full_row</code> is <code>false</code>, only the <code>id_text</code> is returned.</p><p><strong>Arguments</strong></p><ul><li><p><strong>For <code>get_adjacent_id(db::SQLite.DB, current_id; direction, full_row)</code></strong>:</p><ul><li><code>db::SQLite.DB</code>: An active SQLite database connection.</li><li><code>current_id</code>: The current record&#39;s ID from which to find the adjacent record.</li><li><code>direction::String=&quot;next&quot;</code>: The direction to search for the adjacent record. Use <code>&quot;next&quot;</code> for the record with an ID greater than <code>current_id</code>, or <code>&quot;previous&quot;</code> (or <code>&quot;prev&quot;</code>) for the record with an ID less than <code>current_id</code>.</li><li><code>full_row::Bool=true</code>: If <code>true</code>, return the full record (including embedding and meta data); if <code>false</code>, return only the <code>id_text</code>.</li></ul></li><li><p><strong>For <code>get_adjacent_id(db_path::String, current_id; direction, full_row)</code></strong>:</p><ul><li><code>db_path::String</code>: The file path to the SQLite database.</li><li>Other parameters are as described above.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li>When <code>full_row</code> is <code>true</code>: A named tuple <code>(id_text, embedding, data_type)</code> representing the adjacent record.</li><li>When <code>full_row</code> is <code>false</code>: The adjacent record&#39;s <code>id_text</code>.</li><li>Returns <code>nothing</code> if no adjacent record is found.</li><li>For the <code>db_path</code> overload, a <code>String</code> error message is returned if an error occurs.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Using an active database connection:
adjacent = get_adjacent_id(db, 100; direction=&quot;previous&quot;, full_row=false)
if adjacent !== nothing
    println(&quot;Adjacent ID: &quot;, adjacent)
else
    println(&quot;No adjacent record found.&quot;)
end

# Using a database file path:
result = get_adjacent_id(&quot;my_database.db&quot;, 100; direction=&quot;next&quot;)
if result isa NamedTuple
    println(&quot;Adjacent record: &quot;, result)
else
    println(&quot;Error or record not found: &quot;, result)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/WunDeeDB.jl#L1324-L1368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.get_all_embeddings-Tuple{SQLite.DB}" href="#WunDeeDB.get_all_embeddings-Tuple{SQLite.DB}"><code>WunDeeDB.get_all_embeddings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_all_embeddings(db::SQLite.DB)
get_all_embeddings(db_path::String)</code></pre><p>Fetches all embeddings from the main table, converting raw BLOB data into typed vectors.   Returns a <code>Dict{String, Any}</code> mapping each <code>id_text</code> to its corresponding embedding.</p><p><strong>Method 1</strong>: <code>get_all_embeddings(db::SQLite.DB)</code>   Uses the provided open database connection.</p><p><strong>Method 2</strong>: <code>get_all_embeddings(db_path::String)</code>   Opens a database (or reuses a global handle) from the given path. On success, returns the same dictionary of embeddings; on error, returns a string describing the error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/WunDeeDB.jl#L1156-L1169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.get_all_ids-Tuple{SQLite.DB}" href="#WunDeeDB.get_all_ids-Tuple{SQLite.DB}"><code>WunDeeDB.get_all_ids</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_all_ids(db::SQLite.DB)
get_all_ids(db_path::String)</code></pre><p>Retrieves all <code>id_text</code> values from the main table, returning them as a <code>Vector{String}</code>.</p><ul><li><strong>get<em>all</em>ids(db::SQLite.DB)</strong>: Uses the provided open database connection.</li><li><strong>get<em>all</em>ids(db_path::String)</strong>: Opens or reuses a global DB connection from the given path; returns the same vector of IDs on success or an error string on failure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/WunDeeDB.jl#L1212-L1221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.get_embeddings-Tuple{SQLite.DB, Any}" href="#WunDeeDB.get_embeddings-Tuple{SQLite.DB, Any}"><code>WunDeeDB.get_embeddings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Retrieve one or more embeddings from the SQLite database by their ID(s)</p><p>This function is overloaded to support:</p><ul><li><code>get_embeddings(db::SQLite.DB, id_input)</code>: Retrieves embeddings using an active database connection.</li><li><code>get_embeddings(db_path::String, id_input)</code>: Opens the database at the specified path, retrieves embeddings, and then closes the connection.</li></ul><p>When a single ID is provided, the corresponding embedding vector is returned (or <code>nothing</code> if not found). When multiple IDs are provided, a dictionary mapping each ID (as a string) to its embedding vector is returned.</p><p><strong>Arguments</strong></p><ul><li>For <code>get_embeddings(db::SQLite.DB, id_input)</code>:<ul><li><code>db::SQLite.DB</code>: An active SQLite database connection.</li><li><code>id_input</code>: A single ID or an array of IDs identifying the embeddings to retrieve.</li></ul></li><li>For <code>get_embeddings(db_path::String, id_input)</code>:<ul><li><code>db_path::String</code>: The file path to the SQLite database.</li><li><code>id_input</code>: A single ID or an array of IDs identifying the embeddings to retrieve.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li>A single embedding vector if one ID is provided, or a dictionary mapping IDs (as strings) to embedding vectors if multiple IDs are provided.</li><li>Returns <code>nothing</code> if a single requested ID is not found.</li><li>A <code>String</code> error message if an error occurs during retrieval.</li></ul><p><strong>Examples</strong></p><p>Using an active database connection:</p><pre><code class="language-julia hljs">embedding = get_embeddings(db, 42)
if embedding === nothing
    println(&quot;Embedding not found.&quot;)
else
    println(&quot;Embedding: &quot;, embedding)
end

Using a database file path:

embeddings = get_embeddings(&quot;my_database.db&quot;, [1, 2, 3])
for (id, emb) in embeddings
    println(&quot;ID: &#39;id&#39;, Embedding: &quot;, emb)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/WunDeeDB.jl#L1057-L1097">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.get_meta_data-Tuple{SQLite.DB}" href="#WunDeeDB.get_meta_data-Tuple{SQLite.DB}"><code>WunDeeDB.get_meta_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Retrieve meta data from the SQLite database.</p><p>This function is overloaded to accept either an active database connection or a file path:</p><ul><li><code>get_meta_data(db::SQLite.DB)</code>: Retrieves the meta data from the given open database connection.</li><li><code>get_meta_data(db_path::String)</code>: Opens the database at the specified path, retrieves the meta data, and then closes the connection.</li><li>neither approach will close the DB if a persistent handle is in use and tries to use the persistent one if possible.</li></ul><p><strong>Arguments</strong></p><ul><li>For <code>get_meta_data(db::SQLite.DB)</code>:<ul><li><code>db::SQLite.DB</code>: An active SQLite database connection.</li></ul></li><li>For <code>get_meta_data(db_path::String)</code>:<ul><li><code>db_path::String</code>: The file path to the SQLite database.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li>The first row of meta data as a named tuple if it exists, or <code>nothing</code> if no meta data is found.</li><li>If an error occurs (in the <code>db_path</code> overload), a <code>String</code> error message is returned.</li></ul><p><strong>Examples</strong></p><p>Using an existing database connection:</p><pre><code class="language-julia hljs">meta = get_meta_data(db)
if meta !== nothing
    println(&quot;Meta data: &quot;, meta)
else
    println(&quot;No meta data available.&quot;)
end

Using a database file path:

result = get_meta_data(&quot;my_database.db&quot;)
if result isa NamedTuple
    println(&quot;Meta data: &quot;, result)
else
    println(&quot;Error: &quot;, result)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/WunDeeDB.jl#L478-L516">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.get_supported_data_types-Tuple{}" href="#WunDeeDB.get_supported_data_types-Tuple{}"><code>WunDeeDB.get_supported_data_types</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_supported_data_types() -&gt; Vector{String}</code></pre><p>Returns a sorted vector of supported data type names as strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/utilities/utilities.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.infer_data_type-Tuple{AbstractVector{&lt;:Number}}" href="#WunDeeDB.infer_data_type-Tuple{AbstractVector{&lt;:Number}}"><code>WunDeeDB.infer_data_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Infer the data type of the elements in a numeric embedding vector.</p><p><strong>Arguments</strong></p><ul><li><code>embedding::AbstractVector{&lt;:Number}</code>: A vector containing numerical values.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>String</code> representing the element type of the embedding.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">vec = [1.0, 2.0, 3.0]
println(infer_data_type(vec))  # &quot;Float64&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/utilities/utilities.jl#L23-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.initialize_db-Tuple{String, Int64, String}" href="#WunDeeDB.initialize_db-Tuple{String, Int64, String}"><code>WunDeeDB.initialize_db</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Initialize a SQLite database by setting up the main and meta tables with appropriate configuration.</p><p><strong>Arguments</strong></p><ul><li><code>db_path::String</code>: Path to the SQLite database file.</li><li><code>embedding_length::Int</code>: Length of the embedding vector. Must be 1 or greater.</li><li><code>data_type::String</code>: Data type for the embeddings. Must be one of the supported types (use <code>get_supported_data_types()</code> to see valid options).</li><li><code>description::String=&quot;&quot;</code>: (optional) User selected description meta data, defaults to empty string</li><li><code>keep_conn_open::Bool=true</code>: (optional) Keep the DB connection open for rapid successive uses or false for multiple applications to release</li><li><code>ann</code>: optional for the type of ann to use [&#39;hnsw&#39;,&#39;lmdiskann&#39;] if none is provided it is brute force linear search</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> on successful initialization.</li><li>A <code>String</code> error message if any parameter is invalid or if an exception occurs during initialization.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = initialize_db(&quot;my_database.db&quot;, 128, &quot;float32&quot;, description=&quot;embeddings from 01/01/25&quot;, keep_conn_open=true)
if result === true
    println(&quot;Database initialized successfully!&quot;)
else
    println(&quot;Initialization failed: &#39;result&#39;&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/WunDeeDB.jl#L163-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.insert_embeddings-Tuple{SQLite.DB, Any, Any}" href="#WunDeeDB.insert_embeddings-Tuple{SQLite.DB, Any, Any}"><code>WunDeeDB.insert_embeddings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Insert one or more embeddings into a specified collection in the SQLite database.</p><p>This function is overloaded to support:</p><ul><li><strong>Active Connection</strong>: <code>insert_embeddings(db::SQLite.DB, id_input, embedding_input)</code></li><li><strong>Database Path</strong>: <code>insert_embeddings(db_path::String, id_input, embedding_input)</code></li></ul><p>In both cases, the function validates that the provided embeddings have a consistent length and that their data type matches the meta information stored in the database. For the method accepting a database path, the connection is automatically opened and closed.</p><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code> or <code>db_path::String</code>: Either an active SQLite database connection or the file path to the database.</li><li><code>id_input</code>: A single ID or an array of IDs corresponding to the embeddings.</li><li><code>embedding_input</code>: A single numeric embedding vector or an array of embedding vectors. All embeddings must be of the same length.</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if the embeddings are successfully inserted.</li><li>A <code>String</code> error message if an error occurs.</li></ul><p><strong>Examples</strong></p><p>Using an active database connection:</p><pre><code class="language-julia hljs">result = insert_embeddings(db, [1, 2], [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])
if result === true
    println(&quot;Embeddings inserted successfully.&quot;)
else
    println(&quot;Error: &quot;, result)
end

Using a database file path:

result = insert_embeddings(&quot;my_database.db&quot;, 1, [0.1, 0.2, 0.3])
if result === true
    println(&quot;Embedding inserted successfully.&quot;)
else
    println(&quot;Error: &quot;, result)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/WunDeeDB.jl#L630-L668">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.linear_search_all_embeddings-Tuple{String, AbstractVector, String}" href="#WunDeeDB.linear_search_all_embeddings-Tuple{String, AbstractVector, String}"><code>WunDeeDB.linear_search_all_embeddings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_search_all_embeddings(db_path::String, query_embedding::AbstractVector, metric::String; top_k::Int=5)</code></pre><p>Performs a brute-force linear search over all embeddings stored in the database located at <code>db_path</code>.   For each embedding, the function computes the distance to the provided <code>query_embedding</code> using the specified   <code>metric</code> (e.g., &quot;euclidean&quot; or &quot;cosine&quot;). It then maintains the top <code>top_k</code> nearest results using a max-heap   and returns a vector of tuples <code>(distance, id_text)</code>, sorted in ascending order by distance.</p><p>If <code>get_all_embeddings(db_path)</code> returns an error message (as a String), this function immediately returns that error.</p><p><strong>Arguments</strong></p><ul><li><code>db_path::String</code>: Path to the SQLite database file.</li><li><code>query_embedding::AbstractVector</code>: The query embedding vector.</li><li><code>metric::String</code>: The distance metric to use (e.g., &quot;euclidean&quot;, &quot;cosine&quot;).</li><li><code>top_k::Int=5</code>: (Optional) The number of nearest neighbors to return.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of <code>(distance, id_text)</code> tuples sorted by ascending distance, or an error message String if retrieval fails.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">query = Float32[0.5, 0.5, 0.5]
results = linear_search_all_embeddings(&quot;my_database.sqlite&quot;, query, &quot;euclidean&quot;; top_k=3)
for (dist, id) in results
    println(&quot;ID: &quot;, id, &quot;  Distance: &quot;, dist)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/linear/linear.jl#L159-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.linear_search_ids-Tuple{String, AbstractVector, String}" href="#WunDeeDB.linear_search_ids-Tuple{String, AbstractVector, String}"><code>WunDeeDB.linear_search_ids</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_search_ids(db_path::String, query_embedding::AbstractVector, metric::String; top_k::Int=5)</code></pre><p>Performs a brute-force linear search by fetching all IDs at once (<code>get_all_ids</code>) and  computing the distance to <code>query_embedding</code> for each. Maintains the <code>top_k</code> closest  results, returning them sorted by ascending distance as tuples <code>(distance, id_text)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">results = linear_search_ids(&quot;my_database.sqlite&quot;, my_query_embedding, &quot;euclidean&quot;; top_k=5)
for (dist, id) in results
    println(&quot;ID: &quot;, id, &quot;  Distance: &quot;, dist)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/linear/linear.jl#L39-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.linear_search_ids_batched-Tuple{String, AbstractVector, String}" href="#WunDeeDB.linear_search_ids_batched-Tuple{String, AbstractVector, String}"><code>WunDeeDB.linear_search_ids_batched</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_search_ids_batched(db_path::String, query_embedding::AbstractVector, metric::String; top_k::Int=5, batch_size::Int=1000)</code></pre><p>Performs a batched brute-force linear search over embeddings stored in the database at <code>db_path</code>.   The function retrieves all IDs using <code>get_all_ids</code> and then processes the embeddings in batches   (of size <code>batch_size</code>). For each batch, it computes the distance from each embedding to the   <code>query_embedding</code> using the specified <code>metric</code> (e.g., &quot;euclidean&quot; or &quot;cosine&quot;). It maintains   the top <code>top_k</code> nearest results using a max-heap and returns a vector of tuples <code>(distance, id_text)</code>   sorted in ascending order by distance.</p><p>If an error occurs during the retrieval of embeddings (for example, if <code>get_embeddings</code> returns an   error message), the function immediately returns that error message as a String.</p><p><strong>Arguments</strong></p><ul><li><code>db_path::String</code>: Path to the SQLite database file.</li><li><code>query_embedding::AbstractVector</code>: The query embedding vector.</li><li><code>metric::String</code>: The distance metric to use (e.g., &quot;euclidean&quot;, &quot;cosine&quot;).</li><li><code>top_k::Int=5</code>: (Optional) The number of nearest neighbors to return.</li><li><code>batch_size::Int=1000</code>: (Optional) The number of IDs to process in each batch.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of <code>(distance, id_text)</code> tuples sorted by ascending distance, or a String containing   an error message if retrieval fails.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">query = Float32[0.5, 0.5, 0.5]
results = linear_search_ids_batched(&quot;my_database.sqlite&quot;, query, &quot;euclidean&quot;; top_k=3, batch_size=100)
for (dist, id) in results
    println(&quot;ID: &quot;, id, &quot;  Distance: &quot;, dist)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/linear/linear.jl#L83-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.linear_search_iteration-Tuple{String, AbstractVector, String}" href="#WunDeeDB.linear_search_iteration-Tuple{String, AbstractVector, String}"><code>WunDeeDB.linear_search_iteration</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_search_iteration(db_path::String, query_embedding::AbstractVector, metric::String; top_k::Int=5)</code></pre><p>Performs a brute-force linear search by iterating over each embedding in the database using <code>get_adjacent_id</code>. Computes the distance to <code>query_embedding</code> according to <code>metric</code> and returns the top <code>top_k</code> nearest results, sorted by ascending distance. Each result is a  tuple <code>(distance, id_text)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/linear/linear.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.open_db-Tuple{String}" href="#WunDeeDB.open_db-Tuple{String}"><code>WunDeeDB.open_db</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>open<em>db(db</em>path::String) -&gt; SQLite.DB</p><p>Open an SQLite database located at the specified file path, ensuring that the directory exists.</p><p>This function performs the following steps:</p><ol><li><p><strong>Directory Check and Creation:</strong>   It determines the directory path for <code>db_path</code> and checks whether it exists. If the directory does not exist, the function attempts to create it using <code>mkpath</code>.   If directory creation fails, an error is raised with a descriptive message.</p></li><li><p><strong>Database Connection and Configuration:</strong>   The function opens an SQLite database connection using <code>SQLite.DB(db_path)</code>.   It then sets two PRAGMA options for improved write performance:</p><ul><li><code>journal_mode</code> is set to <code>WAL</code> (Write-Ahead Logging).</li><li><code>synchronous</code> is set to <code>NORMAL</code>.</li></ul></li><li><p><strong>Return Value:</strong>   The configured SQLite database connection is returned.</p></li></ol><p><strong>Arguments</strong></p><ul><li><code>db_path::String</code>: The file path to the SQLite database. The function will ensure that the directory containing this file exists</li><li><code>keep_conn_open::Bool</code>: Optional, whether the connection should persist on the session after the function returns</li></ul><p><strong>Returns</strong></p><ul><li>An instance of <code>SQLite.DB</code> representing the open and configured database connection.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">db = open_db(&quot;data/mydatabase.sqlite&quot;, keep_conn_open=&quot;true&quot;)
# Use the database connection...
SQLite.execute(db, &quot;SELECT * FROM my_table;&quot;)
# Don&#39;t forget to close the database when done.
close_db(db)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/WunDeeDB.jl#L262-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.random_embeddings-Tuple{SQLite.DB, Int64}" href="#WunDeeDB.random_embeddings-Tuple{SQLite.DB, Int64}"><code>WunDeeDB.random_embeddings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Randomly retrieve a specified number of embeddings from the SQLite database.</p><p>This function is overloaded to support two usage patterns:</p><ul><li><code>random_embeddings(db::SQLite.DB, num::Int)</code>: Retrieves embeddings using an active database connection.</li><li><code>random_embeddings(db_path::String, num::Int)</code>: Opens the database at the specified path, retrieves embeddings, and then closes the connection.</li></ul><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code> or <code>db_path::String</code>: Either an active SQLite database connection or the file path to the SQLite database.</li><li><code>num::Int</code>: The number of random embeddings to retrieve.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Dict{String, Any}</code> mapping each embedding&#39;s ID (as a string) to its embedding vector.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">embeddings = random_embeddings(&quot;my_database.db&quot;, 5)
for (id, emb) in embeddings
    println(&quot;ID: &#39;id&#39;, Embedding: &quot;, emb)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/WunDeeDB.jl#L1248-L1269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.supported_distance_metrics-Tuple{}" href="#WunDeeDB.supported_distance_metrics-Tuple{}"><code>WunDeeDB.supported_distance_metrics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">supported_distance_metrics()</code></pre><p>Returns a list of the currently supported distance metrics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/distance_metrics/distance_metrics.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.update_description" href="#WunDeeDB.update_description"><code>WunDeeDB.update_description</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Update the description in the metadata table.</p><p>This function can be called in two ways:</p><ol><li>With an open SQLite.DB connection.</li><li>With a database file path, which will open the connection if needed.</li></ol><p>It executes a parameterized query to update the description field. If an error occurs, the function closes the database connection, resets global connection variables, and returns an error message.</p><p>Arguments:</p><ul><li><code>db::SQLite.DB</code> or <code>db_path::String</code>: A SQLite database connection or the path to the database file.</li><li><code>description::String</code> (optional): The new description to set (defaults to an empty string).</li></ul><p>Returns:</p><ul><li>true on success, or a string with the error message on failure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/WunDeeDB.jl#L545-L561">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.update_embeddings-Tuple{SQLite.DB, Any, Any}" href="#WunDeeDB.update_embeddings-Tuple{SQLite.DB, Any, Any}"><code>WunDeeDB.update_embeddings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Update one or more embeddings in the SQLite database with new embedding data.</p><p>This function is overloaded to support two usage patterns:</p><ul><li><code>update_embeddings(db::SQLite.DB, id_input, new_embedding_input)</code>: Updates embeddings using an active database connection.</li><li><code>update_embeddings(db_path::String, id_input, new_embedding_input)</code>: Opens the database at the specified path, updates the embeddings, and then closes the connection.</li></ul><p>The function accepts a single identifier or an array of identifiers along with corresponding new embedding vectors. It validates that all new embeddings have the same length, and that their length and data type match the values stored in the meta table. For single record updates, it additionally confirms that the record exists in the database.</p><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code> or <code>db_path::String</code>: Either an active database connection or the file path to the SQLite database.</li><li><code>id_input</code>: A single ID or an array of IDs identifying the embeddings to update.</li><li><code>new_embedding_input</code>: A single numeric embedding vector or an array of such vectors. All embeddings must be of consistent length.</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if the update is successful.</li><li>A <code>String</code> error message if an error occurs.</li></ul><p><strong>Examples</strong></p><p>Using an active database connection:</p><pre><code class="language-julia hljs">result = update_embeddings(db, 1, [0.5, 0.6, 0.7])
if result === true
    println(&quot;Embedding updated successfully.&quot;)
else
    println(&quot;Error: &quot;, result)
end

Using a database file path:

result = update_embeddings(&quot;my_database.db&quot;, [1, 2], [[0.5, 0.6, 0.7], [0.8, 0.9, 1.0]])
if result === true
    println(&quot;Embeddings updated successfully.&quot;)
else
    println(&quot;Error: &quot;, result)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/b8bc50b84c366076c34d6a77e4276109145034d9/src/WunDeeDB.jl#L912-L950">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Monday 16 June 2025 17:01">Monday 16 June 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
